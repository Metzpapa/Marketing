<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Balanced Eye Point Cloud</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: white; 
            font-family: sans-serif;
        }
        canvas { display: block; }

        #captureBtn {
            padding: 12px 24px;
            background: white;
            border: 2px solid #333;
            color: #333;
            font-size: 14px;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.3s;
            text-transform: uppercase;
            letter-spacing: 2px;
            font-weight: bold;
            width: 100%;
            margin-top: 15px;
        }
        #captureBtn:hover {
            background: #333;
            color: white;
        }

        #controls {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            z-index: 10;
            width: 250px;
            max-height: calc(100vh - 60px);
            overflow-y: auto;
        }

        #controls h3 {
            margin: 0 0 15px 0;
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #333;
            border-bottom: 1px solid #ddd;
            padding-bottom: 10px;
        }

        .control-group {
            margin-bottom: 15px;
        }

        .control-group label {
            display: block;
            font-size: 11px;
            color: #666;
            margin-bottom: 5px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .control-group input[type="range"] {
            width: 100%;
            margin: 0;
        }

        .control-group .value {
            font-size: 12px;
            color: #333;
            float: right;
            font-weight: bold;
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>

<div id="controls">
    <h3>Cloud Controls</h3>

    <div class="control-group">
        <label>Cloud Density <span class="value" id="densityVal">150000</span></label>
        <input type="range" id="density" min="50000" max="300000" step="10000" value="150000">
    </div>

    <div class="control-group">
        <label>Cloud Size <span class="value" id="sizeVal">12</span></label>
        <input type="range" id="cloudSize" min="8" max="20" step="0.5" value="12">
    </div>

    <div class="control-group">
        <label>Inner Cutoff <span class="value" id="innerVal">4</span></label>
        <input type="range" id="innerSize" min="2" max="6" step="0.5" value="4">
    </div>

    <div class="control-group">
        <label>Fade Falloff <span class="value" id="falloffVal">2.5</span></label>
        <input type="range" id="falloff" min="0.5" max="5" step="0.1" value="2.5">
    </div>

    <div class="control-group">
        <label>Point Size <span class="value" id="pointSizeVal">0.035</span></label>
        <input type="range" id="pointSize" min="0.01" max="0.1" step="0.005" value="0.035">
    </div>

    <div class="control-group">
        <label>Point Opacity <span class="value" id="opacityVal">0.8</span></label>
        <input type="range" id="opacity" min="0.1" max="1" step="0.05" value="0.8">
    </div>

    <div class="control-group">
        <label>Fog Density <span class="value" id="fogVal">0.02</span></label>
        <input type="range" id="fog" min="0" max="0.1" step="0.005" value="0.02">
    </div>

    <button id="captureBtn">Capture Frame</button>
</div>

<script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

    // 1. SETUP
    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0xffffff, 0.02);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.z = 14; 
    camera.position.y = 0;

    const renderer = new THREE.WebGLRenderer({ 
        antialias: true, 
        alpha: true,               
        preserveDrawingBuffer: true 
    });
    
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2)); 
    document.body.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.autoRotate = false; 

    // ==========================================
    // PARAMETERS (controlled by UI)
    // ==========================================

    let params = {
        cloudCount: 150000,
        maxCloudSize: 12.0,
        minCloudSize: 4.0,
        falloff: 2.5,
        pointSize: 0.035,
        opacity: 0.8,
        fogDensity: 0.02
    };

    // ==========================================
    // GENERATION LOGIC
    // ==========================================

    function randomPointOnSphere(radius) {
        const u = Math.random();
        const v = Math.random();
        const theta = 2 * Math.PI * u;
        const phi = Math.acos(2 * v - 1);
        const x = radius * Math.sin(phi) * Math.cos(theta);
        const y = radius * Math.sin(phi) * Math.sin(theta);
        const z = radius * Math.cos(phi);
        return { x, y, z };
    }

    function generatePointCloud() {
        const vertices = [];

        // --- LAYER 1: THE CLOUD (SQUARE/CUBE SHAPE) ---
        for (let i = 0; i < params.cloudCount; i++) {
            let x = (Math.random() * 2 - 1) * params.maxCloudSize;
            let y = (Math.random() * 2 - 1) * params.maxCloudSize;
            let z = (Math.random() * 2 - 1) * params.maxCloudSize;

            const distFromCenter = Math.max(Math.abs(x), Math.abs(y), Math.abs(z));
            const sphereDist = Math.sqrt(x*x + y*y + z*z);
            if (sphereDist < params.minCloudSize) continue;

            const normalizedDist = (distFromCenter - params.minCloudSize) / (params.maxCloudSize - params.minCloudSize);
            const keepProbability = Math.pow(1 - normalizedDist, params.falloff);
            if (Math.random() > keepProbability) continue;

            vertices.push(x, y, z);
        }

        // --- LAYER 2: THE EYE STRUCTURE ---
        const eyeballCount = 20000;
        const eyeRadius = 4.0;
        for (let i = 0; i < eyeballCount; i++) {
            let p = randomPointOnSphere(eyeRadius);
            const cutoffNoise = (Math.random() * 0.2) - 0.1;
            if (p.z > 3.2 + cutoffNoise) continue;
            vertices.push(p.x, p.y, p.z);
        }

        // --- IRIS ---
        const irisCount = 10000;
        const irisRadius = 2.3;
        const pupilRadius = 0.8;
        for (let i = 0; i < irisCount; i++) {
            const r = Math.sqrt(Math.random()) * irisRadius;
            const theta = Math.random() * 2 * Math.PI;
            if (r < pupilRadius) continue;
            const x = r * Math.cos(theta);
            const y = r * Math.sin(theta);
            const z = 3.5 - (r * 0.2);
            vertices.push(x, y, z);
        }

        // --- EYELIDS ---
        const lidCount = 15000;
        const lidRadius = 4.3;
        for (let i = 0; i < lidCount; i++) {
            let p = randomPointOnSphere(lidRadius);
            const openingHeight = 1.8 * (1 - Math.abs(p.x / lidRadius));
            if (p.z > 0 && Math.abs(p.y) < openingHeight) continue;
            vertices.push(p.x, p.y, p.z);
        }

        return new Float32Array(vertices);
    }

    // ==========================================
    // RENDER SETTINGS
    // ==========================================

    const geometry = new THREE.BufferGeometry();
    geometry.setAttribute('position', new THREE.BufferAttribute(generatePointCloud(), 3));

    const material = new THREE.PointsMaterial({
        color: 0x000000,
        size: params.pointSize,
        sizeAttenuation: true,
        transparent: true,
        opacity: params.opacity,
        depthWrite: false
    });

    const pointCloud = new THREE.Points(geometry, material);
    scene.add(pointCloud);

    // ==========================================
    // UI CONTROLS
    // ==========================================

    function updateValue(id, value) {
        document.getElementById(id).textContent = value;
    }

    function rebuildCloud() {
        geometry.setAttribute('position', new THREE.BufferAttribute(generatePointCloud(), 3));
        geometry.attributes.position.needsUpdate = true;
    }

    // Density
    document.getElementById('density').addEventListener('input', (e) => {
        params.cloudCount = parseInt(e.target.value);
        updateValue('densityVal', params.cloudCount);
    });
    document.getElementById('density').addEventListener('change', rebuildCloud);

    // Cloud Size
    document.getElementById('cloudSize').addEventListener('input', (e) => {
        params.maxCloudSize = parseFloat(e.target.value);
        updateValue('sizeVal', params.maxCloudSize);
    });
    document.getElementById('cloudSize').addEventListener('change', rebuildCloud);

    // Inner Cutoff
    document.getElementById('innerSize').addEventListener('input', (e) => {
        params.minCloudSize = parseFloat(e.target.value);
        updateValue('innerVal', params.minCloudSize);
    });
    document.getElementById('innerSize').addEventListener('change', rebuildCloud);

    // Falloff
    document.getElementById('falloff').addEventListener('input', (e) => {
        params.falloff = parseFloat(e.target.value);
        updateValue('falloffVal', params.falloff);
    });
    document.getElementById('falloff').addEventListener('change', rebuildCloud);

    // Point Size (instant update)
    document.getElementById('pointSize').addEventListener('input', (e) => {
        params.pointSize = parseFloat(e.target.value);
        updateValue('pointSizeVal', params.pointSize);
        material.size = params.pointSize;
    });

    // Opacity (instant update)
    document.getElementById('opacity').addEventListener('input', (e) => {
        params.opacity = parseFloat(e.target.value);
        updateValue('opacityVal', params.opacity);
        material.opacity = params.opacity;
    });

    // Fog (instant update)
    document.getElementById('fog').addEventListener('input', (e) => {
        params.fogDensity = parseFloat(e.target.value);
        updateValue('fogVal', params.fogDensity);
        scene.fog.density = params.fogDensity;
    });

    // ==========================================
    // CAPTURE FUNCTIONALITY
    // ==========================================

    const btn = document.getElementById('captureBtn');
    
    btn.addEventListener('click', () => {
        renderer.render(scene, camera);

        // Create a square crop based on viewport height
        const size = window.innerHeight;
        const sourceX = (window.innerWidth - size) / 2; // Center horizontally

        // Create a temporary canvas for the square crop
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = size;
        tempCanvas.height = size;
        const ctx = tempCanvas.getContext('2d');

        // Draw the cropped square from the center of the renderer
        ctx.drawImage(
            renderer.domElement,
            sourceX * window.devicePixelRatio,  // Source X (account for pixel ratio)
            0,                                   // Source Y
            size * window.devicePixelRatio,     // Source width
            size * window.devicePixelRatio,     // Source height
            0,                                   // Dest X
            0,                                   // Dest Y
            size,                                // Dest width
            size                                 // Dest height
        );

        const strMime = "image/png";
        const imgData = tempCanvas.toDataURL(strMime);

        const link = document.createElement('a');
        const filename = 'point-cloud-eye-balanced.png';

        link.download = filename;
        link.href = imgData;

        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    });

    // ==========================================
    // ANIMATION LOOP
    // ==========================================
    
    function animate() {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
    }

    animate();

    window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    });
</script>
</body>
</html>